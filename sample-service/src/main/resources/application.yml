# sample-service/application.yml

# ZCM SDK Configuration (minimal)
zcm:
  sdk:
    service:
      name: sample-service
    config:
      server:
        url: ${CONFIG_SERVER_URL:http://localhost:8888}
    control:
      url: ${ZCM_SDK_CONTROL_URL:http://config-control-service:8080}
    bus:
      kafka:
        bootstrap-servers: ${KAFKA_BROKERS:localhost:9092}
      refresh:
        enabled: true # Enable refresh listener
    ping:
      enabled: true # Enable ping to config-control-service
      fixed-delay: 30000 # 30 seconds
    discovery:
      consul:
        host: consul
        heartbeat:
          enabled: true # Enable Consul heartbeat
        register: true # Enable Consul registration
    feature-flags:
      enabled: false # Enable Unleash Feature Flags
      unleash-api-url: ${UNLEASH_API_URL:http://unleash:4242/api/}
      api-key: ${UNLEASH_API_KEY:default:development.unleash-insecure-api-token}
      app-name: ${zcm.sdk.service.name} # Auto-mapped from service name
      instance-id: ${zcm.sdk.instance.id} # Auto-mapped from instance ID
      synchronous-fetch-on-initialisation: true
      send-metrics-interval: 60
    kv:
      enabled: true # Enable Key-Value store functionality
      keycloak:
        token-endpoint: ${ZCM_SDK_KV_KEYCLOAK_TOKEN_ENDPOINT:http://keycloak:8080/realms/config-control/protocol/openid-connect/token}
        client-id: ${ZCM_SDK_KV_KEYCLOAK_CLIENT_ID:config-control-service}
        client-secret: ${ZCM_SDK_KV_KEYCLOAK_CLIENT_SECRET:${KEYCLOAK_CLIENT_SECRET:config-control-service-secret}}
        realm: ${ZCM_SDK_KV_KEYCLOAK_REALM:config-control}
    api-key:
      enabled: ${ZCM_SDK_API_KEY_ENABLED:true} # Enable API key authentication (preferred over JWT)
      key: ${ZCM_SDK_API_KEY:zcm-sdk-api-key-default-change-in-production} # API key for SDK client authentication

# Application server port
server:
  port: 8080
  # 'tomcat.threads.max' sets the maximum number of request-processing threads for the embedded Tomcat server.
  # This controls how many HTTP requests can be served concurrently.
  # For example: if set to 50, up to 50 requests can be processed at the same time; additional requests will wait in the connection queue (controlled by 'accept-count').
  tomcat:
    threads: # Worker 
      max: 50
      max-queue-capacity: 1000
    # The accept-count property controls the maximum number of incoming connections that
    # can be queued when all request processing threads are busy. If more than this number
    # of requests arrive while all request threads are in use, additional connections will be
    # refused or closed until there is room in the queue.
    accept-count: 5000 # Connection queue

# Profile activation
spring:
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
  # cloud:
  #   config:
  #     allow-override: true
  #     override-none: true
  # threads:
  #   virtual:
  #     enabled: true
  # main:
  #   keep-alive: true

# Actuator endpoints (SDK auto-exposes refresh/busrefresh)
management:
  endpoints:
    web:
      exposure:
        include: "health,refresh,busrefresh,env,configprops,loggers,threaddump,heapdump,caches,circuitbreakers,retries,timelimiters"
  endpoint:
    health:
      show-details: always
    refresh:
      enabled: true
    busrefresh:
      enabled: true
    env:
      post:
        enabled: true

# Logging configuration is handled by log4j2-spring.xml
# This section is kept for backward compatibility but log4j2-spring.xml takes precedence
logging:
  level:
    root: INFO
    com.example.sample: DEBUG
    com.vng.zing.zcm: DEBUG

