# Infrastructure Configuration
# Config Server client configuration
config-server:
  url: ${CONFIG_SERVER_URL:http://config-server:8888}
  timeout: 5000
  retry:
    max-attempts: 3
    backoff-delay: 1000
  service-discovery:
    enabled: ${CONFIG_SERVER_SERVICE_DISCOVERY_ENABLED:true}
    service-name: ${CONFIG_SERVER_SERVICE_NAME:config-server}
    fallback-to-url: ${CONFIG_SERVER_FALLBACK_TO_URL:true}
  loadbalancer:
    strategy: ${CONFIG_SERVER_LOADBALANCER_STRATEGY:round-robin} # round-robin, random, health-based

# Config Proxy settings
config:
  proxy:
    # Enable mock mode to avoid GitHub rate limits during testing/load testing
    # When enabled, services not in whitelist-services will receive mock config hashes
    mock-mode-enabled: ${CONFIG_PROXY_MOCK_MODE_ENABLED:true}
    
    # Mock strategy: DETERMINISTIC (stable), RANDOM (varies), STATIC (fixed)
    # - DETERMINISTIC: Same hash for same service:env (stable for testing)
    # - RANDOM: Different hash each time (test drift detection)
    # - STATIC: Fixed hash value (test steady state)
    mock-strategy: ${CONFIG_PROXY_MOCK_STRATEGY:DETERMINISTIC}
    
    # Services that always fetch real config from Config Server (whitelist)
    # These services will bypass mock mode even when mock-mode-enabled=true
    whitelist-services:
      - sample-service
      # Add other critical services here
    
    # Static hash value (used when mock-strategy=STATIC)
    static-mock-hash: ${CONFIG_PROXY_STATIC_MOCK_HASH:mock-hash-static-12345}
    
    # Log when mock hash is returned (for observability)
    log-mock-usage: ${CONFIG_PROXY_LOG_MOCK_USAGE:true}

# Consul client configuration
consul:
  url: ${CONSUL_URL:http://consul:8500}
  timeout: 5000
  retry:
    max-attempts: 3
    backoff-delay: 1000

# New Consul SDK Configuration
consulclient:
  consul-url: ${CONSUL_URL:http://consul:8500}
  token: ${CONSUL_TOKEN:}
  connect-timeout: 5s
  read-timeout: 10s
  write-timeout: 10s

# RestClient timeout configuration
rest-client:
  connect-timeout: 5s
  read-timeout: 10s
  write-timeout: 10s
  clients:
    configserver:
      connect-timeout: 5s
      read-timeout: 10s
      write-timeout: 10s
    consul:
      connect-timeout: 5s
      read-timeout: 10s
      write-timeout: 10s
    keycloak:
      connect-timeout: 5s
      read-timeout: 10s
      write-timeout: 10s

# RPC Server Configuration (Thrift and gRPC)
rpc:
  server:
    thrift-port: ${THRIFT_PORT:9090}
    grpc-port: ${GRPC_PORT:9091}

# KV Store Configuration
kv:
  backend: ${KV_BACKEND:consul} # consul or etcd
  consul:
    base-url: ${KV_CONSUL_URL:http://consul:8500}
    wait: 5m
    token: ${KV_CONSUL_TOKEN:}
  etcd:
    endpoints:
      - ${KV_ETCD_ENDPOINTS:http://etcd:2379}
    connect-timeout: 5s
    keepalive-time: 10s
    namespace: ${KV_ETCD_NAMESPACE:}

# Service Instance Cleanup Configuration
service-instance:
  cleanup:
    enabled: false
    stale-threshold-minutes: 10
    cleanup-threshold-days: 30
    schedule-cron: "0 */5 * * * *" # Every 5 minutes

# Heartbeat Configuration
app:
  heartbeat:
    async:
      enabled: ${HEARTBEAT_ASYNC_ENABLED:true}
    kafka:
      topic: ${HEARTBEAT_KAFKA_TOPIC:heartbeat-queue}
      consumer:
        concurrency: ${HEARTBEAT_KAFKA_CONSUMER_CONCURRENCY:10}
        max-retries: ${HEARTBEAT_KAFKA_CONSUMER_MAX_RETRIES:3}
      dlq:
        topic: ${HEARTBEAT_KAFKA_DLQ_TOPIC:heartbeat-queue-dlq}
  observability:
    environment: ${APP_ENVIRONMENT:development}
    otlp:
      tracing:
        endpoint: ${MANAGEMENT_OTLP_TRACING_ENDPOINT:http://alloy:4318/v1/traces}
      metrics:
        url: ${MANAGEMENT_OTLP_METRICS_EXPORT_URL:http://alloy:4318/v1/metrics}
  name: ${APP_NAME:config-control-service}
  version: ${APP_VERSION:1.0.0}
  environment: ${APP_ENVIRONMENT:development}

# Spring Cloud LoadBalancer Configuration
spring:
  cloud:
    loadbalancer:
      config:
        config-server:
          strategy: ${CONFIG_SERVER_LOADBALANCER_STRATEGY:round-robin}

