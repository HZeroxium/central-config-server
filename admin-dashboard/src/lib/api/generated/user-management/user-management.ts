/**
 * Generated by orval v7.14.0 üç∫
 * Do not edit manually.
 * Config Control Service API
 * Centralized configuration management and drift detection service.

**Features:**
- Service instance heartbeat tracking
- Configuration drift detection and reporting
- Service discovery integration with Consul
- Config refresh orchestration via Kafka
- Real-time monitoring and alerts

**Architecture:**
- Hexagonal architecture with distinct API, Application, Domain, and Infrastructure layers
- MongoDB for persistence
- Redis for caching
- Kafka for event broadcasting

 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ErrorResponse,
  MeResponse,
  PermissionsResponse
} from '../../models';

import { customInstance } from '../../mutator';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Retrieve detailed information about the currently authenticated user.
This includes user ID, username, email, names, team memberships, roles, and manager ID.

 * @summary Get current user information
 */
export const findCurrentUserInformation = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MeResponse>(
      {url: `/api/user/whoami`, method: 'GET', signal
    },
      options);
    }
  



export const getFindCurrentUserInformationInfiniteQueryKey = () => {
    return [
    'infinite', `/api/user/whoami`
    ] as const;
    }

export const getFindCurrentUserInformationQueryKey = () => {
    return [
    `/api/user/whoami`
    ] as const;
    }

    
export const getFindCurrentUserInformationInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformation>>>, TError = ErrorResponse | ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCurrentUserInformationInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCurrentUserInformation>>> = ({ signal }) => findCurrentUserInformation(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindCurrentUserInformationInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findCurrentUserInformation>>>
export type FindCurrentUserInformationInfiniteQueryError = ErrorResponse | ErrorResponse


export function useFindCurrentUserInformationInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformation>>>, TError = ErrorResponse | ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserInformation>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserInformation>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserInformationInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformation>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserInformation>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserInformation>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserInformationInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformation>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user information
 */

export function useFindCurrentUserInformationInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformation>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindCurrentUserInformationInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getFindCurrentUserInformationQueryOptions = <TData = Awaited<ReturnType<typeof findCurrentUserInformation>>, TError = ErrorResponse | ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCurrentUserInformationQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCurrentUserInformation>>> = ({ signal }) => findCurrentUserInformation(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindCurrentUserInformationQueryResult = NonNullable<Awaited<ReturnType<typeof findCurrentUserInformation>>>
export type FindCurrentUserInformationQueryError = ErrorResponse | ErrorResponse


export function useFindCurrentUserInformation<TData = Awaited<ReturnType<typeof findCurrentUserInformation>>, TError = ErrorResponse | ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserInformation>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserInformation>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserInformation<TData = Awaited<ReturnType<typeof findCurrentUserInformation>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserInformation>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserInformation>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserInformation<TData = Awaited<ReturnType<typeof findCurrentUserInformation>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user information
 */

export function useFindCurrentUserInformation<TData = Awaited<ReturnType<typeof findCurrentUserInformation>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindCurrentUserInformationQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Legacy endpoint for retrieving current user information.
This is an alias for the /whoami endpoint for backward compatibility.

 * @summary Get current user information (legacy)
 */
export const findCurrentUserInformationLegacy = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MeResponse>(
      {url: `/api/user/me`, method: 'GET', signal
    },
      options);
    }
  



export const getFindCurrentUserInformationLegacyInfiniteQueryKey = () => {
    return [
    'infinite', `/api/user/me`
    ] as const;
    }

export const getFindCurrentUserInformationLegacyQueryKey = () => {
    return [
    `/api/user/me`
    ] as const;
    }

    
export const getFindCurrentUserInformationLegacyInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>>, TError = ErrorResponse | ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCurrentUserInformationLegacyInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>> = ({ signal }) => findCurrentUserInformationLegacy(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindCurrentUserInformationLegacyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>>
export type FindCurrentUserInformationLegacyInfiniteQueryError = ErrorResponse | ErrorResponse


export function useFindCurrentUserInformationLegacyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>>, TError = ErrorResponse | ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserInformationLegacyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserInformationLegacyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user information (legacy)
 */

export function useFindCurrentUserInformationLegacyInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindCurrentUserInformationLegacyInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getFindCurrentUserInformationLegacyQueryOptions = <TData = Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError = ErrorResponse | ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCurrentUserInformationLegacyQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>> = ({ signal }) => findCurrentUserInformationLegacy(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindCurrentUserInformationLegacyQueryResult = NonNullable<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>>
export type FindCurrentUserInformationLegacyQueryError = ErrorResponse | ErrorResponse


export function useFindCurrentUserInformationLegacy<TData = Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError = ErrorResponse | ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserInformationLegacy<TData = Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserInformationLegacy<TData = Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user information (legacy)
 */

export function useFindCurrentUserInformationLegacy<TData = Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserInformationLegacy>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindCurrentUserInformationLegacyQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Retrieve comprehensive permission information for the current user.
This includes allowed API routes, UI routes, roles, teams, actions, and service access.

**Permission Matrix:**
- API routes: Endpoints the user can access
- UI routes: Frontend pages the user can navigate to
- Actions: Specific operations the user can perform
- Services: Owned and shared services the user can access

 * @summary Get user permissions and routes
 */
export const findCurrentUserPermissions = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PermissionsResponse>(
      {url: `/api/user/me/permissions`, method: 'GET', signal
    },
      options);
    }
  



export const getFindCurrentUserPermissionsInfiniteQueryKey = () => {
    return [
    'infinite', `/api/user/me/permissions`
    ] as const;
    }

export const getFindCurrentUserPermissionsQueryKey = () => {
    return [
    `/api/user/me/permissions`
    ] as const;
    }

    
export const getFindCurrentUserPermissionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserPermissions>>>, TError = ErrorResponse | ErrorResponse>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCurrentUserPermissionsInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCurrentUserPermissions>>> = ({ signal }) => findCurrentUserPermissions(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindCurrentUserPermissionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findCurrentUserPermissions>>>
export type FindCurrentUserPermissionsInfiniteQueryError = ErrorResponse | ErrorResponse


export function useFindCurrentUserPermissionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserPermissions>>>, TError = ErrorResponse | ErrorResponse>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserPermissions>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserPermissions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserPermissionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserPermissions>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserPermissions>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserPermissions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserPermissionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserPermissions>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user permissions and routes
 */

export function useFindCurrentUserPermissionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof findCurrentUserPermissions>>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindCurrentUserPermissionsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getFindCurrentUserPermissionsQueryOptions = <TData = Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError = ErrorResponse | ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCurrentUserPermissionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCurrentUserPermissions>>> = ({ signal }) => findCurrentUserPermissions(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindCurrentUserPermissionsQueryResult = NonNullable<Awaited<ReturnType<typeof findCurrentUserPermissions>>>
export type FindCurrentUserPermissionsQueryError = ErrorResponse | ErrorResponse


export function useFindCurrentUserPermissions<TData = Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError = ErrorResponse | ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserPermissions>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserPermissions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserPermissions<TData = Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findCurrentUserPermissions>>,
          TError,
          Awaited<ReturnType<typeof findCurrentUserPermissions>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFindCurrentUserPermissions<TData = Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user permissions and routes
 */

export function useFindCurrentUserPermissions<TData = Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCurrentUserPermissions>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFindCurrentUserPermissionsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



